# algo14_2

## 문제 1. 친구 네트워크 탐색

### 문제 목적  
주어진 사람과 직·간접적으로 연결된 모든 친구 수를 구하는 것
---

### 입력 처리 방식

- 사용자로부터 문자열 형태로 입력된 친구 관계를 `ast` 모듈을 사용해 리스트 형태로 변환하여 처리함
---

### 함수 구성

- `make_graph()` 함수
- 입력된 친구 관계 리스트를 기반으로 **양방향 그래프(dict)**를 생성
- 친구 관계가 상호적이라는 점을 반영하여, 각 간선을 **양방향으로 저장**

---

- `dfs()` 함수
- **깊이 우선 탐색(DFS)** 알고리즘을 **재귀 방식**으로 구현
- `visited` 리스트를 사용하여 **이미 방문한 노드를 중복 방문하지 않도록** 방지
- 탐색 결과로 **시작 노드와 연결된 모든 노드의 리스트**를 반환

---

-  `find_connection()` 함수
- DFS 탐색 결과를 기반으로:
  - 총 연결된 사람 수
  - 연결된 노드 목록
  을 출력하는 함수
- 최종 출력 형식 예시: `3(1,2,3)`
---


## 문제 2. 루트 트리의 깊이 계산

### 선택 알고리즘: DFS

### 선택 이유  
- 이 문제는 각 노드의 깊이(depth)를 계산해야 하므로, 노드를 따라 끝까지 탐색할 수 있는 DFS가 적합
- BFS는 깊이 계산에는 적절하지 않으며, 모든 경로의 순서를 기억해야 하므로 비효율적

### DFS의 적용  
- 트리의 구조상 한 노드에서 자식 노드로 순차적으로 내려가며 깊이를 누적할 수 있기 때문에 DFS가 적절

---

### 입력 처리 방식

- 사용자로부터 입력받은 간선 정보를 문자열 형태로 받고,  `ast` 모듈을 사용해 안전하게 리스트 형태로 파싱하여 처리

---

### 함수 구성

- `make_graph()` 함수
- 입력된 `(부모, 자식)` 형태의 간선 리스트를 기반으로 양방향 그래프(dict)로 변환
- 트리 구조는 단방향이나, DFS 탐색을 수월하게 하기 위해 양방향 저장 사용

---

-  `dfs()` 함수
- 각 노드의 깊이 값을 계산하여 `new_dict`에 저장하는 재귀 함수
- 자식 노드로 내려갈 때마다 깊이를 1씩 증가시켜 재귀 호출

---

-  `cal_depth()` 함수
- `dfs()`를 호출하여 깊이 정보를 수집한 후,
- 노드 번호 기준으로 정렬하여 출력



## 문제 3. 최대 이익 배낭 문제 (Fractional Knapsack)

### 선택 알고리즘: 탐욕적 알고리즘

선택 이유  
- 이 문제는 무게를 기준으로 최대 이익을 구하는 문제이기 때문에 단위 무게당 가치가 높은 것부터 선택하는 방식이 적합하다  
- 문제를 잘게 쪼갤 수 있으며, 남은 공간도 같은 방식으로 해결 가능하므로 탐욕적 알고리즘의 조건을 만족한다  
- 따라서 매 단계에서 가장 이익이 되는 선택이 전체 최적해로 이어지기 때문에 이 알고리즘을 사용할 수 있다

---

### 입력 처리 방식

- 사용자로부터 입력받은 물건 리스트를 문자열로 받아 `ast` 모듈을 사용해 리스트 형태로 변환하여 처리한다

---

### FK 함수

- 최대 이익을 계산하는 함수
- 단위 가치를 계산하여 단위 가치가 높은 것부터 차례대로 배낭에 담는다
- 배낭에 전부 담을 수 있으면 모두 담고, 공간이 부족하면 일부만 담는다

---

### 문제 구조 분석

1. 문제를 잘게 쪼갤 수 있고, 각 단계에서 가장 좋은 선택이 전체 최적해로 이어지기 때문에 탐욕적 알고리즘을 사용할 수 있다  
2. 물건을 쪼갤 수 있기 때문에, 단위 가치 기준 선택이 항상 옳다  
3. 각 단위가 독립적으로 처리되며, 최적 부분 구조를 만족한다

---

## 문제 4. 작업 지연 최소화

### 선택 알고리즘: 탐욕적 알고리즘

선택 이유  
- 마감 시간이 있는 작업들은 마감 시간 순서 또는 마감시간과 소요시간의 조합을 고려해 하나씩 선택하면서 전체 최적해에 도달할 수 있다  
- 각 작업을 일단 하나씩 고정하고, 남은 작업에도 같은 전략을 반복 적용할 수 있기 때문에 탐욕적 알고리즘의 조건을 만족한다  
- 따라서 마감 시간이 빠른 작업부터 선택하는 것이 총 지연 시간을 최소화하는 데 효과적이다

---


## 문제 5. 최소 동전 개수

### 선택 알고리즘: DP (동적 계획법)

선택 이유  
- 이 문제는 중복 부분 문제가 자주 발생하므로,  
  탐욕적 선택보다는 이전에 계산된 결과를 저장해 재사용하는 DP가 더 적합하다  
---

### 구현상의 보완점

- 현재 구조에서는 최소 개수는 계산할 수 있지만 어떤 동전이 사용되었는지는 추적이 어렵다
- 향후 개선 시, 각 금액에 대해 어떤 동전을 선택했는지를  
  딕셔너리나 배열 형태로 저장하면 구성 추적도 가능할 것으로 예상된다

---

## 문제 6.  LCS (최장 공통 부분 수열)
